Отчет о нагрузочном тестировании глоссария терминов (REST и gRPC)
=================================================================

1\. Описание тестируемого приложения
------------------------------------

Приложение представляет собой глоссарий терминов с двумя интерфейсами:

-   REST API -- реализован на FastAPI, работает по протоколу HTTP/1.1, порт 8000.

-   gRPC API -- реализован на основе gRPC (Python), протокол HTTP/2, порт 50051.

### Функциональность

-   Чтение списка всех терминов (упрощённый вид).

-   Чтение полной информации о конкретном термине.

-   Добавление нового термина (с указанием названия, определения, списка источников и связанных терминов).

-   Обновление существующего термина.

-   Удаление термина.

### Технологии

-   Бэкенд: Python (FastAPI + SQLAlchemy для REST; grpcio + SQLite для gRPC).

-   База данных: SQLite (файл `terms.db`), одна таблица.

-   Контейнеризация: оба сервиса запускаются в отдельных Docker-контейнерах, связанных через docker-compose.

2\. Настройки тестовой среды
----------------------------

### Аппаратные ресурсы

Тестирование проводилось на локальной машине:

-   Процессор: CPU Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz

-   Оперативная память: 8 ГБ DDR4

-   Сетевой модуль: Intel(R) Wi-Fi 6 AX201 160MHz

-   ОС: Windows 11 (с WSL 2 для Docker)

### Архитектура стенда

-   REST-сервис: контейнер с FastAPI, порт 8000 проброшен на хост.

-   gRPC-сервис: отдельный контейнер с gRPC-сервером, порт 50051 проброшен на хост.

-   Генерация нагрузки: Locust запущен на хосте (вне Docker) и обращался к localhost:8000 (REST) и localhost:50051 (gRPC).

-   База данных SQLite для каждого сервиса своя (не разделялась).

### Версия Locust

Из окружения использование Python 3.14,  Locust 2.32.

### Дополнительные инструменты

Не использовались -- метрики собирались только средствами Locust (статистика, CSV-отчёты).

3\. Тестовые сценарии
---------------------

Для каждого протокола были проведены четыре типа тестов, соответствующие общепринятой методологии:

-   light -- лёгкая нагрузка (10 пользователей), проверка работоспособности.

-   normal -- рабочая нагрузка (50 пользователей), имитация реального использования.

-   stress -- стресс-тест (200 пользователей), поиск пределов производительности.

-   stability -- тест на стабильность (50 пользователей в течение длительного времени), проверка деградации.

### 3.1. Логика виртуального пользователя

Для REST API использовался класс `GlossaryUser` (файл `locustfile.py` для REST).\
Основные задачи с весами:

-   `get_all_terms` (вес 10) -- получение всех терминов.

-   `get_specific_term` (вес 8) -- получение конкретного термина.

-   `create_term` (вес 3) -- создание нового термина.

-   `update_term` (вес 2) -- обновление случайного термина.

-   `delete_term` (вес 1) -- удаление термина (только тестовых, начинающихся с `test_`).

Фрагмент кода (REST):

python

@task(10)
def get_all_terms(self):
    self.client.get("/terms", name="GET /terms")

@task(8)
def get_specific_term(self):
    term = self.random_term()
    if term:
        self.client.get(f"/terms/{term}", name="GET /terms/{term}")

Для gRPC использовался класс `GlossaryUser` с аналогичным набором методов, обёрнутых в `GrpcClient`, который замеряет время и отправляет события Locust.

Фрагмент кода (gRPC):

python

@task(30)
def get_all_terms(self):
    self.grpc_client.GetAllTerms(Empty())

@task(30)
def get_term_by_name(self):
    name = self.get_random_term()
    if name:
        self.grpc_client.GetTermByName(TermName(name=name))

### 3.2. Конфигурация нагрузки

| Тест | Протокол | Число пользователей | Spawn rate (польз/сек) | Запланированная длительность | Фактическая длительность | Всего запросов |
| --- | --- | --- | --- | --- | --- | --- |
| light | REST | 10 | 1 | 1 мин | ~17 сек | 85 |
| light | gRPC | 10 | 1 | 1 мин | ~55 сек | 190 |
| normal | REST | 50 | 5 | 5 мин | ~4 сек | 59 |
| normal | gRPC | 50 | 5 | 5 мин | ~5 мин | 4908 |
| stress | REST | 200 | 10 | 10 мин | ~32 сек | 36 |
| stress | gRPC | 200 | 10 | 10 мин | ~41 мин | 39303 |
| stability | REST | 50 | 5 | 30 мин | ~15 сек | 130 |
| stability | gRPC | 50 | 5 | 30 мин | ~27 мин | 29826 |

> *Примечание:* Тесты REST завершались досрочно из-за резкого роста времени ответа и ошибок (деградации). gRPC-тесты отработали полное запланированное время.

### 3.3. Гипотезы перед тестированием

-   REST на FastAPI с SQLite должен выдерживать десятки одновременных пользователей со средним временем ответа < 100 мс.

-   gRPC благодаря бинарному протоколу и мультиплексированию должен показать более высокую пропускную способность и меньшую задержку.

-   Основным узким местом станет база данных SQLite (блокировки при конкурентной записи).

-   При длительном тесте возможно ухудшение производительности из-за фрагментации БД или утечек памяти.

4\. Результаты тестирования
---------------------------

### 4.1. Лёгкая нагрузка (light)

#### REST

| Метод | Запросов | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки |
| --- | --- | --- | --- | --- | --- |
| GET /terms (упрощ.) | 10 | 33.8 | 77 | 77 | 0 |
| GET /terms (с именем) | 36 | 12.5 | 27 | 28 | 0 |
| GET /terms/{term} | 21 | 20.3 | 28 | 87 | 0 |
| POST /terms | 8 | 80.2 | 140 | 140 | 0 |
| PUT /terms/{term} | 4 | 126.8 | 150 | 150 | 0 |
| DELETE /terms/{term} | 6 | 37.5 | 87 | 87 | 1 |
| Всего | 85 | 30.4 | 110 | 140 | 1 |

RPS (общий): 5.0\
График динамики: RPS рос до ~6.4, среднее время ответа колебалось в пределах 25--40 мс, p95 достигало 120 мс в пике.

#### gRPC

| Метод | Запросов | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки |
| --- | --- | --- | --- | --- | --- |
| GetAllTerms | 82 | 7.0 | 9 | 47 | 0 |
| GetTermByName | 58 | 6.0 | 7 | 38 | 0 |
| GetGraph | 38 | 5.8 | 8 | 8 | 0 |
| AddTerm | 7 | 6.0 | 11 | 11 | 0 |
| UpdateTerm | 4 | 7.5 | 8 | 8 | 0 |
| DeleteTerm | 1 | 8.3 | 8 | 8 | 0 |
| Всего | 190 | 6.4 | 8 | 38 | 0 |

RPS (общий): 3.3 (меньше из-за более длительных пауз между задачами в сценарии)

Анализ: gRPC показывает очень низкую и стабильную латентность (5--8 мс) даже при небольшом количестве запросов. REST тоже в пределах нормы, но операции записи уже заметно медленнее.

### 4.2. Рабочая нагрузка (normal)

#### REST (тест прервался через 4 секунды, данные ограничены)

| Метод | Запросов | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки |
| --- | --- | --- | --- | --- | --- |
| GET /terms (упрощ.) | 20 | 56.1 | 95 | 95 | 0 |
| GET /terms (с именем) | 20 | 25.2 | 74 | 74 | 0 |
| GET /terms/{term} | 8 | 15.3 | 29 | 29 | 0 |
| POST /terms | 6 | 69.4 | 110 | 110 | 0 |
| PUT /terms/{term} | 3 | 66.8 | 110 | 110 | 1 |
| DELETE /terms/{term} | 2 | 27.9 | 28 | 28 | 0 |
| Всего | 59 | 41.0 | 95 | 110 | 1 |

RPS (общий): 14.9

Анализ: Несмотря на кратковременность, видно, что время ответа для чтения выросло (~56 мс для полного списка). Появилась ошибка PUT. Тест не позволяет судить о стабильности, но указывает на начинающуюся деградацию.

#### gRPC

| Метод | Запросов | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки |
| --- | --- | --- | --- | --- | --- |
| GetAllTerms | 1665 | 5.6 | 8 | 23 | 0 |
| GetTermByName | 1652 | 4.8 | 7 | 8 | 56 |
| GetGraph | 1127 | 5.4 | 8 | 9 | 0 |
| AddTerm | 260 | 5.3 | 8 | 10 | 0 |
| UpdateTerm | 165 | 5.4 | 8 | 10 | 0 |
| DeleteTerm | 39 | 7.3 | 10 | 47 | 0 |
| Всего | 4908 | 5.3 | 8 | 10 | 56 |

RPS (общий): 16.4

Анализ: gRPC сохраняет высокую производительность -- среднее время ответа 5.3 мс, RPS 16.4. Ошибки GetTermByName (56) -- это `NOT_FOUND`, вызванные попыткой получить термин, который был удалён ранее. Это не ошибка сервера, а особенность сценария.

### 4.3. Стресс-тест (stress)

#### REST

| Метод | Запросов | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки |
| --- | --- | --- | --- | --- | --- |
| GET /terms (упрощ.) | 33 | 5581 | 7000 | 30000 | 1 |
| GET /terms/{term} | 1 | 4167 | 4200 | 4200 | 0 |
| POST /terms | 2 | 3690 | 5200 | 5200 | 0 |
| Всего | 36 | 5436 | 7000 | 30000 | 1 |

RPS (общий): 1.12

График динамики: Время ответа сразу выросло до секунд, один запрос занял 30 секунд (вероятно, таймаут). RPS упал ниже 3.

#### gRPC

| Метод | Запросов | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки |
| --- | --- | --- | --- | --- | --- |
| GetAllTerms | 13393 | 5.2 | 11 | 15 | 0 |
| GetTermByName | 13162 | 3.2 | 7 | 7 | 181 |
| GetGraph | 8685 | 5.2 | 11 | 13 | 0 |
| AddTerm | 2222 | 3.4 | 7 | 8 | 0 |
| UpdateTerm | 1496 | 3.4 | 7 | 8 | 0 |
| DeleteTerm | 345 | 6.8 | 13 | 19 | 0 |
| Всего | 39303 | 4.4 | 9 | 13 | 181 |

RPS (общий): 65.7

Анализ: gRPC выдерживает 200 пользователей без деградации -- среднее время 4.4 мс, RPS 65.7. Ошибки (181) -- снова `NOT_FOUND`. Пропускная способность выросла пропорционально числу пользователей.

### 4.4. Тест на стабильность (stability)

#### REST (длительность ~15 секунд)

| Метод | Запросов | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки |
| --- | --- | --- | --- | --- | --- |
| GET /terms (упрощ.) | 46 | 2841 | 5900 | 6100 | 0 |
| GET /terms (с именем) | 27 | 2373 | 5400 | 5500 | 1 |
| GET /terms/{term} | 39 | 1479 | 6100 | 6700 | 1 |
| POST /terms | 8 | 2928 | 6500 | 6500 | 0 |
| PUT /terms/{term} | 9 | 4147 | 8700 | 8700 | 2 |
| DELETE /terms/{term} | 1 | 94 | 94 | 94 | 0 |
| Всего | 130 | 2410 | 6100 | 8100 | 4 |

RPS (общий): 8.6

Анализ: Деградация наступила мгновенно -- время ответа в секундах. Одна ошибка 500 (GET /terms с именем), остальные -- 4xx? Скорее всего, таймауты или 500.

#### gRPC (длительность ~27 минут)

| Метод | Запросов | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки |
| --- | --- | --- | --- | --- | --- |
| GetAllTerms | 9898 | 11.7 | 20 | 22 | 0 |
| GetTermByName | 9987 | 4.6 | 7 | 8 | 2 |
| GetGraph | 6708 | 11.1 | 19 | 20 | 0 |
| AddTerm | 1628 | 5.0 | 8 | 8 | 0 |
| UpdateTerm | 1294 | 4.9 | 8 | 9 | 0 |
| DeleteTerm | 311 | 15.1 | 26 | 28 | 0 |
| Всего | 29826 | 8.6 | 19 | 21 | 2 |

RPS (общий): 16.6

Анализ: gRPC стабильно работает на протяжении почти получаса. Время ответа даже ниже, чем в стресс-тесте (возможно, из-за меньшего числа пользователей). Единичные ошибки -- `NOT_FOUND`.

5\. Сравнение REST и gRPC
-------------------------

### 5.1. Сводная таблица ключевых метрик

| Тест | Протокол | RPS | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки | Примечание |
| --- | --- | --- | --- | --- | --- | --- | --- |
| light | REST | 5.0 | 30.4 | 110 | 140 | 1 | Нормально |
| light | gRPC | 3.3 | 6.4 | 8 | 38 | 0 | Меньше RPS из-за wait_time |
| normal | REST | 14.9 | 41.0 | 95 | 110 | 1 | Тест короткий, начало дегр. |
| normal | gRPC | 16.4 | 5.3 | 8 | 10 | 56* | Высокая производительность |
| stress | REST | 1.1 | 5436 | 7000 | 30000 | 1 | Полная деградация |
| stress | gRPC | 65.7 | 4.4 | 9 | 13 | 181* | Отличная масштабируемость |
| stability | REST | 8.6 | 2410 | 6100 | 8100 | 4 | Быстрый провал |
| stability | gRPC | 16.6 | 8.6 | 19 | 21 | 2* | Стабильность подтверждена |

* Ошибки gRPC -- преимущественно `NOT_FOUND` (клиентские), не связаны с производительностью сервера.

### 5.2. Латентность при росте нагрузки

-   REST: латентность резко возрастает при переходе от 10 к 50 пользователям (с 30 мс до 41 мс, а при 200 -- до секунд). Причина -- блокировки SQLite и накладные расходы HTTP/1.1.

-   gRPC: латентность практически не меняется с ростом числа пользователей (остаётся в районе 4--9 мс). Это говорит об эффективной работе протокола и отсутствии конкуренции за ресурсы (вероятно, из-за быстрой обработки запросов и короткого времени удержания блокировок БД).

### 5.3. Пропускная способность

-   REST достигает пика RPS ~15 при 50 пользователях, но затем падает до 1 при 200.

-   gRPC линейно увеличивает RPS до 65 при 200 пользователях, без признаков насыщения (при текущей конфигурации).

### 5.4. Анализ overhead

-   REST использует текстовый JSON, HTTP/1.1 -- это добавляет накладные расходы на сериализацию и размер пакетов. FastAPI, хоть и асинхронный, не спасает, когда БД блокируется.

-   gRPC использует бинарный протокол (protobuf) и HTTP/2 с мультиплексированием, что минимизирует задержки и эффективно использует одно соединение.

Вывод: gRPC обеспечивает на порядок лучшую производительность и масштабируемость для данного приложения.

6\. Заключение
--------------

### Основные выводы

1.  REST API на FastAPI с SQLite приемлем только при очень низкой нагрузке (до ~10 пользователей). При 50 пользователях начинается деградация, при 200 -- сервис практически неработоспособен (время ответа в секундах, RPS падает до 1).

2.  gRPC API демонстрирует отличную масштабируемость: при 200 пользователях RPS достигает 65, среднее время ответа 4--5 мс, p99 < 15 мс. Длительный тест (27 минут) подтверждает стабильность.

3.  Основным узким местом REST является SQLite -- блокировки при конкурентной записи и даже чтении. gRPC благодаря более быстрой обработке запросов снижает время удержания блокировок, но SQLite остаётся ограничивающим фактором. Тем не менее, для gRPC он достаточен.

4.  Ошибки в gRPC-тестах (`NOT_FOUND`) связаны с логикой тестового сценария (удаление терминов) и не являются проблемой сервера.

### Рекомендации по оптимизации

-   Для REST-сервиса:

    -   Перейти на асинхронный драйвер БД (aiosqlite) и настроить пул соединений.

    -   Включить WAL-режим SQLite (`PRAGMA journal_mode=WAL`), увеличить кэш.

    -   Добавить кэширование (Redis) для часто запрашиваемых данных.

    -   Рассмотреть замену SQLite на PostgreSQL для высокой конкурентности.

-   Для gRPC-сервиса:

    -   Минимизировать ошибки `NOT_FOUND` путём синхронизации списка терминов или использования идемпотентных операций.

    -   Добавить мониторинг ресурсов (CPU, память) для раннего обнаружения проблем.

### Возможные улучшения эксперимента

-   Провести тесты с одинаковыми профилями нагрузки и длительностью для обоих протоколов.

-   Измерять потребление CPU и памяти контейнеров во время тестов.

-   Использовать распределённый режим Locust для исключения влияния одного генератора.

-   Протестировать различные соотношения чтения/записи.

### Ограничения проведённого тестирования

-   Тесты REST были слишком короткими из-за быстрой деградации, что не позволяет оценить поведение на длительных интервалах.

-   Не измерялась нагрузка на сеть и влияние сетевых задержек.

-   Генератор нагрузки и сервисы находились на одной машине -- возможна конкуренция за ресурсы CPU.

-   Версии библиотек и протоколов не фиксировались.

* * * * *

Итог: Для высоконагруженных систем или микросервисной архитектуры настоятельно рекомендуется использовать gRPC. REST может быть оставлен для совместимости или демонстрационных целей, но требует серьёзной оптимизации (замена БД, кэширование).

### 1\. Сравнительный анализ REST, GraphQL и gRPC для разработки API: практическое бенчмаркинг-исследование

-   Авторы/Источник: Sven Reichersdörfer, [Theseus.fi](https://theseus.fi/) (2025) [](https://www.theseus.fi/handle/10024/904498).

-   Суть исследования: Для сравнения была разработана система управления задачами (аналог Trello) на [ASP.NET](https://asp.net/) Core и SQLite. Оценивались не только производительность, но и удобство для разработчика, поддерживаемость и пригодность к реальным проектам [](https://www.theseus.fi/handle/10024/904498).

-   Ключевые результаты:

    -   REST оказался самым простым в реализации и обладает наилучшей совместимостью.

    -   GraphQL предоставил гибкость в запросах, но добавил сложности в настройку.

    -   gRPC показал самую высокую производительность и эффективность коммуникации, однако вызвал трудности с отладкой и начальным освоением [](https://www.theseus.fi/handle/10024/904498).

-   Вывод: Выбор стиля API зависит от контекста. REST остается надежным универсальным выбором, GraphQL хорош для data-ориентированных приложений, а gRPC оптимален для высокопроизводительного общения между сервисами [](https://www.theseus.fi/handle/10024/904498).

### 2\. Оценка производительности коммуникации микросервисов с REST, GraphQL и gRPC

-   Авторы/Источник: Muhammad Niswar et al., International Journal of Electronics and Telecommunications (2024) [](https://www.semanticscholar.org/paper/Performance-evaluation-of-microservices-with-REST%2C-Niswar-Safruddin/8526bef65e8d241155be2ce807989afc146f0b18)[](https://ijet.pl/index.php/ijet/article/view/10.24425-ijet.2024.149562)[](https://doaj.org/article/57cd5b1b88204a43bfbb2fd245c989e0).

-   Суть исследования: Было создано три микросервиса в отдельных контейнерах, каждый с базами Redis и MySQL. Сравнение проводилось по времени ответа и загрузке CPU при выборке "плоских" и "вложенных" данных с количеством запросов от 100 до 500 [](https://ijet.pl/index.php/ijet/article/view/10.24425-ijet.2024.149562)[](https://doaj.org/article/57cd5b1b88204a43bfbb2fd245c989e0).

-   Ключевые результаты:

    -   gRPC показал самое быстрое время ответа [](https://www.semanticscholar.org/paper/Performance-evaluation-of-microservices-with-REST%2C-Niswar-Safruddin/8526bef65e8d241155be2ce807989afc146f0b18)[](https://ijet.pl/index.php/ijet/article/view/10.24425-ijet.2024.149562)[](https://doaj.org/article/57cd5b1b88204a43bfbb2fd245c989e0).

    -   REST занял второе место по скорости, за ним следует GraphQL [](https://ijet.pl/index.php/ijet/article/view/10.24425-ijet.2024.149562)[](https://doaj.org/article/57cd5b1b88204a43bfbb2fd245c989e0).

    -   GraphQL продемонстрировал более высокое потребление CPU по сравнению с gRPC и REST [](https://ijet.pl/index.php/ijet/article/view/10.24425-ijet.2024.149562)[](https://doaj.org/article/57cd5b1b88204a43bfbb2fd245c989e0).

-   Вывод: Результаты дают понимание для разработчиков и архитекторов при выборе протокола коммуникации под конкретные задачи и рабочие нагрузки [](https://ijet.pl/index.php/ijet/article/view/10.24425-ijet.2024.149562).

### 3\. Сравнительный анализ RESTful, GraphQL и gRPC API: понимание производительности из нагрузочного и стресс-тестирования

-   Авторы/Источник: DOAJ (2024) [](https://doaj.org/article/65ddca6d02214f999bc79190da4eefde).

-   Суть исследования: Проведены нагрузочное и стресс-тестирование трех архитектур API с использованием набора данных из 1000 записей. Оценивались потребление CPU, памяти, время отклика, загрузки, задержки, процент успешных и ошибочных запросов [](https://doaj.org/article/65ddca6d02214f999bc79190da4eefde).

-   Ключевые результаты:

    -   RESTful достиг наивысшего общего количества запросов, но показал большее потребление ресурсов и более высокий процент ошибок [](https://doaj.org/article/65ddca6d02214f999bc79190da4eefde).

    -   GraphQL продемонстрировал лучшую эффективность по CPU и памяти с высокой стабильностью, но с более высокой задержкой и медленным временем ответа [](https://doaj.org/article/65ddca6d02214f999bc79190da4eefde).

    -   gRPC показал сбалансированные результаты с умеренной задержкой и потреблением ресурсов, но с немного большим потреблением памяти при стрессе [](https://doaj.org/article/65ddca6d02214f999bc79190da4eefde).

-   Вывод: RESTful подходит для сценариев с высокой пропускной способностью, GraphQL --- для эффективности и стабильности, а gRPC --- для сбалансированной работы [](https://doaj.org/article/65ddca6d02214f999bc79190da4eefde).

### 4\. Сравнение коммуникации микросервисов, разработанных на нескольких языках программирования

-   Авторы/Источник: Lucas Martins Chaves, Университет Пассо Фундо, Бразилия (2024) [](http://repositorio.upf.br/handle/riupf/2842?locale=en).

-   Суть исследования: Были разработаны приложения на Go, JavaScript и Python, реализующие REST, gRPC и GraphQL. Нагрузочные тесты проводились с помощью K6, данные собирались через Elastic Stack [](http://repositorio.upf.br/handle/riupf/2842?locale=en).

-   Ключевые результаты:

    -   Наибольшую общую производительность показал язык Go [](http://repositorio.upf.br/handle/riupf/2842?locale=en).

    -   GraphQL показал лучшую производительность на операциях вставки (insertions) [](http://repositorio.upf.br/handle/riupf/2842?locale=en).

    -   GraphQL и REST показали схожее поведение, с небольшим преимуществом REST при работе с большими объемами данных [](http://repositorio.upf.br/handle/riupf/2842?locale=en).

### 5\. Анализ производительности моделей протоколов API REST, SOAP, GraphQL и RPC в симуляции операций CRUD, сортировки и поиска данных

-   Авторы/Источник: Abdul Halim Arif, Universitas Malikussaleh, Индонезия (2024) [](http://rama.unimal.ac.id/cgi/exportview/creators/Arif=3AAbdul_Halim=3A=3A/Atom/Arif=3AAbdul_Halim=3A=3A.xml).

-   Суть исследования: Проведено нагрузочное и стресс-тестирование четырех протоколов для измерения реакции и устойчивости системы при различных условиях нагрузки на операциях create, read, update, delete, сортировки и поиска [](http://rama.unimal.ac.id/cgi/exportview/creators/Arif=3AAbdul_Halim=3A=3A/Atom/Arif=3AAbdul_Halim=3A=3A.xml).

-   Ключевые результаты (среднее время ответа / процент ошибок):

    -   Create: REST (10 мс / 41% ошибок), SOAP (65 мс / 28.4%), GraphQL (44 мс / 0%), RPC (29 мс / 0%).

    -   Read: REST (19 мс / 47.2%), SOAP (21 мс / 40.2%), GraphQL (9 мс / 42.8%), RPC (9 мс / 0.4%).

    -   Update: REST (5 мс / 23.6%), SOAP (18 мс / 57%), GraphQL (8 мс / 0%), RPC (20 мс / 1.6%).

    -   Delete: REST (931 мс / 38.4%), SOAP (112 мс / 15.4%), GraphQL (9 мс / 12.6%), RPC (14 мс / 0%).

    -   Sorting: REST (895 мс / 23.4%), SOAP (51 мс / 11.8%), GraphQL (87 мс / 27%), RPC (4 мс / 1%).

    -   Searching: REST (4 мс / 38.4%), SOAP (85 мс / 49.8%), GraphQL (66 мс / 0%), RPC (6 мс / 0.8%).

-   Вывод: RPC и GraphQL показали превосходную производительность в большинстве сценариев, особенно в эффективности и скорости ответа, в то время как REST и SOAP показали недостатки под высокой нагрузкой [](http://rama.unimal.ac.id/cgi/exportview/creators/Arif=3AAbdul_Halim=3A=3A/Atom/Arif=3AAbdul_Halim=3A=3A.xml).

### Сводный анализ результатов

Ниже представлена таблица, обобщающая ключевые выводы из исследованных работ.

| Протокол | Сильные стороны (Performance & Efficiency) | Слабые стороны (Trade-offs) | Типичные сценарии использования [](https://www.dio.me/articles/rest-vs-grpc-vs-graphql-qual-escolher-em-2025-161416be9cec) |
| --- | --- | --- | --- |
| REST | Высокая пропускная способность, простота, отличная совместимость, эффективный кэш [](https://www.theseus.fi/handle/10024/904498)[](https://doaj.org/article/65ddca6d02214f999bc79190da4eefde)[](https://www.dio.me/articles/rest-vs-grpc-vs-graphql-qual-escolher-em-2025-161416be9cec). | Более высокое потребление ресурсов и процент ошибок под нагрузкой, может быть медленнее для сложных запросов [](https://doaj.org/article/65ddca6d02214f999bc79190da4eefde)[](https://ijet.pl/index.php/ijet/article/view/10.24425-ijet.2024.149562)[](http://rama.unimal.ac.id/cgi/exportview/creators/Arif=3AAbdul_Halim=3A=3A/Atom/Arif=3AAbdul_Halim=3A=3A.xml). | Публичные API, сервисы для сторонних разработчиков, веб-сервисы, где важна простота интеграции и кэширование [](https://www.theseus.fi/handle/10024/904498)[](https://www.dio.me/articles/rest-vs-grpc-vs-graphql-qual-escolher-em-2025-161416be9cec). |
| GraphQL | Гибкость запросов, эффективность CPU и памяти, высокая стабильность, отличная производительность на вставках [](https://doaj.org/article/65ddca6d02214f999bc79190da4eefde)[](http://repositorio.upf.br/handle/riupf/2842?locale=en). | Высокая задержка и медленное время ответа, сложность настройки, более высокое потребление CPU в некоторых сценариях [](https://doaj.org/article/65ddca6d02214f999bc79190da4eefde)[](https://ijet.pl/index.php/ijet/article/view/10.24425-ijet.2024.149562)[](https://www.dio.me/articles/rest-vs-grpc-vs-graphql-qual-escolher-em-2025-161416be9cec). | Приложения с разнородными клиентами (web/mobile), агрегация данных из нескольких источников, сложные запросы к связанным данным [](https://www.theseus.fi/handle/10024/904498)[](https://www.dio.me/articles/rest-vs-grpc-vs-graphql-qual-escolher-em-2025-161416be9cec). |
| gRPC | Самая высокая скорость ответа, сбалансированное потребление ресурсов, отличная производительность для CRUD и сортировки, поддержка streaming [](https://www.semanticscholar.org/paper/Performance-evaluation-of-microservices-with-REST%2C-Niswar-Safruddin/8526bef65e8d241155be2ce807989afc146f0b18)[](https://ijet.pl/index.php/ijet/article/view/10.24425-ijet.2024.149562)[](http://rama.unimal.ac.id/cgi/exportview/creators/Arif=3AAbdul_Halim=3A=3A/Atom/Arif=3AAbdul_Halim=3A=3A.xml). | Сложность отладки, более высокое потребление памяти при стрессе, ограниченная поддержка в браузерах [](https://www.theseus.fi/handle/10024/904498)[](https://doaj.org/article/65ddca6d02214f999bc79190da4eefde)[](https://www.dio.me/articles/rest-vs-grpc-vs-graphql-qual-escolher-em-2025-161416be9cec). | Высокопроизводительная коммуникация между микросервисами, системы реального времени, streaming-приложения (IoT, чаты) [](https://www.theseus.fi/handle/10024/904498)[](https://www.dio.me/articles/rest-vs-grpc-vs-graphql-qual-escolher-em-2025-161416be9cec). |

### Заключение

Исследования едины в том, что не существует единственного "лучшего" протокола. Выбор зависит от контекста [](https://www.theseus.fi/handle/10024/904498)[](https://www.dio.me/articles/rest-vs-grpc-vs-graphql-qual-escolher-em-2025-161416be9cec).

-   gRPC является явным лидером по сырой производительности (скорость ответа, эффективность) и идеально подходит для внутренней коммуникации между микросервисами [](https://www.semanticscholar.org/paper/Performance-evaluation-of-microservices-with-REST%2C-Niswar-Safruddin/8526bef65e8d241155be2ce807989afc146f0b18)[](https://ijet.pl/index.php/ijet/article/view/10.24425-ijet.2024.149562)[](http://rama.unimal.ac.id/cgi/exportview/creators/Arif=3AAbdul_Halim=3A=3A/Atom/Arif=3AAbdul_Halim=3A=3A.xml).

-   GraphQL выделяется своей гибкостью и эффективностью использования ресурсов, что делает его отличным выбором для frontend-клиентов и сложных запросов, но ценой более высокой задержки [](https://doaj.org/article/65ddca6d02214f999bc79190da4eefde)[](http://repositorio.upf.br/handle/riupf/2842?locale=en).

-   REST остается надежным и простым стандартом для публичных API, обеспечивая высокую пропускную способность и совместимость, но может потреблять больше ресурсов под высокой нагрузкой [](https://www.theseus.fi/handle/10024/904498)[](https://doaj.org/article/65ddca6d02214f999bc79190da4eefde).

Современные высоконагруженные системы часто используют гибридный подход, применяя каждый протокол для решения наиболее подходящих для него задач [](https://www.dio.me/articles/rest-vs-grpc-vs-graphql-qual-escolher-em-2025-161416be9cec).