Отчет о нагрузочном тестировании глоссария терминов (REST и gRPC)
=================================================================

1\. Описание тестируемого приложения
------------------------------------

Приложение представляет собой глоссарий терминов с двумя интерфейсами:

-   REST API -- реализован на FastAPI, работает по протоколу HTTP/1.1, порт 8000.

-   gRPC API -- реализован на основе gRPC (Python), протокол HTTP/2, порт 50051.

### Функциональность

-   Чтение списка всех терминов (упрощённый вид).

-   Чтение полной информации о конкретном термине.

-   Добавление нового термина (с указанием названия, определения, списка источников и связанных терминов).

-   Обновление существующего термина.

-   Удаление термина.

### Технологии

-   Бэкенд: Python (FastAPI + SQLAlchemy для REST; grpcio + SQLite для gRPC).

-   База данных: SQLite (файл `terms.db`), одна таблица.

-   Контейнеризация: оба сервиса запускаются в отдельных Docker-контейнерах, связанных через docker-compose.

2\. Настройки тестовой среды
----------------------------

### Аппаратные ресурсы

Тестирование проводилось на локальной машине:

-   Процессор: CPU Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz

-   Оперативная память: 8 ГБ DDR4

-   Сетевой модуль: Intel(R) Wi-Fi 6 AX201 160MHz

-   ОС: Windows 11 (с WSL 2 для Docker)

### Архитектура стенда

-   REST-сервис: контейнер с FastAPI, порт 8000 проброшен на хост.

-   gRPC-сервис: отдельный контейнер с gRPC-сервером, порт 50051 проброшен на хост.

-   Генерация нагрузки: Locust запущен на хосте (вне Docker) и обращался к localhost:8000 (REST) и localhost:50051 (gRPC).

-   База данных SQLite для каждого сервиса своя (не разделялась).

### Версия Locust

Из окружения использование Python 3.14,  Locust 2.32.

### Дополнительные инструменты

Не использовались -- метрики собирались только средствами Locust (статистика, CSV-отчёты).

3\. Тестовые сценарии
---------------------

Для каждого протокола были проведены четыре типа тестов, соответствующие общепринятой методологии:

-   light -- лёгкая нагрузка (10 пользователей), проверка работоспособности.

-   normal -- рабочая нагрузка (50 пользователей), имитация реального использования.

-   stress -- стресс-тест (200 пользователей), поиск пределов производительности.

-   stability -- тест на стабильность (50 пользователей в течение длительного времени), проверка деградации.

### 3.1. Логика виртуального пользователя

Для REST API использовался класс `GlossaryUser` (файл `locustfile.py` для REST).\
Основные задачи с весами:

-   `get_all_terms` (вес 10) -- получение всех терминов.

-   `get_specific_term` (вес 8) -- получение конкретного термина.

-   `create_term` (вес 3) -- создание нового термина.

-   `update_term` (вес 2) -- обновление случайного термина.

-   `delete_term` (вес 1) -- удаление термина (только тестовых, начинающихся с `test_`).

Фрагмент кода (REST):

python

@task(10)
def get_all_terms(self):
    self.client.get("/terms", name="GET /terms")

@task(8)
def get_specific_term(self):
    term = self.random_term()
    if term:
        self.client.get(f"/terms/{term}", name="GET /terms/{term}")

Для gRPC использовался класс `GlossaryUser` с аналогичным набором методов, обёрнутых в `GrpcClient`, который замеряет время и отправляет события Locust.

Фрагмент кода (gRPC):

python

@task(30)
def get_all_terms(self):
    self.grpc_client.GetAllTerms(Empty())

@task(30)
def get_term_by_name(self):
    name = self.get_random_term()
    if name:
        self.grpc_client.GetTermByName(TermName(name=name))

### 3.2. Конфигурация нагрузки

| Тест | Протокол | Число пользователей | Spawn rate (польз/сек) | Запланированная длительность | Фактическая длительность | Всего запросов |
| --- | --- | --- | --- | --- | --- | --- |
| light | REST | 10 | 1 | 1 мин | ~17 сек | 85 |
| light | gRPC | 10 | 1 | 1 мин | ~55 сек | 190 |
| normal | REST | 50 | 5 | 5 мин | ~4 сек | 59 |
| normal | gRPC | 50 | 5 | 5 мин | ~5 мин | 4908 |
| stress | REST | 200 | 10 | 10 мин | ~32 сек | 36 |
| stress | gRPC | 200 | 10 | 10 мин | ~41 мин | 39303 |
| stability | REST | 50 | 5 | 30 мин | ~15 сек | 130 |
| stability | gRPC | 50 | 5 | 30 мин | ~27 мин | 29826 |

> *Примечание:* Тесты REST завершались досрочно из-за резкого роста времени ответа и ошибок (деградации). gRPC-тесты отработали полное запланированное время.

### 3.3. Гипотезы перед тестированием

-   REST на FastAPI с SQLite должен выдерживать десятки одновременных пользователей со средним временем ответа < 100 мс.

-   gRPC благодаря бинарному протоколу и мультиплексированию должен показать более высокую пропускную способность и меньшую задержку.

-   Основным узким местом станет база данных SQLite (блокировки при конкурентной записи).

-   При длительном тесте возможно ухудшение производительности из-за фрагментации БД или утечек памяти.

4\. Результаты тестирования
---------------------------

### 4.1. Лёгкая нагрузка (light)

#### REST

| Метод | Запросов | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки |
| --- | --- | --- | --- | --- | --- |
| GET /terms (упрощ.) | 10 | 33.8 | 77 | 77 | 0 |
| GET /terms (с именем) | 36 | 12.5 | 27 | 28 | 0 |
| GET /terms/{term} | 21 | 20.3 | 28 | 87 | 0 |
| POST /terms | 8 | 80.2 | 140 | 140 | 0 |
| PUT /terms/{term} | 4 | 126.8 | 150 | 150 | 0 |
| DELETE /terms/{term} | 6 | 37.5 | 87 | 87 | 1 |
| Всего | 85 | 30.4 | 110 | 140 | 1 |

RPS (общий): 5.0\
График динамики: RPS рос до ~6.4, среднее время ответа колебалось в пределах 25--40 мс, p95 достигало 120 мс в пике.

#### gRPC

| Метод | Запросов | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки |
| --- | --- | --- | --- | --- | --- |
| GetAllTerms | 82 | 7.0 | 9 | 47 | 0 |
| GetTermByName | 58 | 6.0 | 7 | 38 | 0 |
| GetGraph | 38 | 5.8 | 8 | 8 | 0 |
| AddTerm | 7 | 6.0 | 11 | 11 | 0 |
| UpdateTerm | 4 | 7.5 | 8 | 8 | 0 |
| DeleteTerm | 1 | 8.3 | 8 | 8 | 0 |
| Всего | 190 | 6.4 | 8 | 38 | 0 |

RPS (общий): 3.3 (меньше из-за более длительных пауз между задачами в сценарии)

Анализ: gRPC показывает очень низкую и стабильную латентность (5--8 мс) даже при небольшом количестве запросов. REST тоже в пределах нормы, но операции записи уже заметно медленнее.

### 4.2. Рабочая нагрузка (normal)

#### REST (тест прервался через 4 секунды, данные ограничены)

| Метод | Запросов | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки |
| --- | --- | --- | --- | --- | --- |
| GET /terms (упрощ.) | 20 | 56.1 | 95 | 95 | 0 |
| GET /terms (с именем) | 20 | 25.2 | 74 | 74 | 0 |
| GET /terms/{term} | 8 | 15.3 | 29 | 29 | 0 |
| POST /terms | 6 | 69.4 | 110 | 110 | 0 |
| PUT /terms/{term} | 3 | 66.8 | 110 | 110 | 1 |
| DELETE /terms/{term} | 2 | 27.9 | 28 | 28 | 0 |
| Всего | 59 | 41.0 | 95 | 110 | 1 |

RPS (общий): 14.9

Анализ: Несмотря на кратковременность, видно, что время ответа для чтения выросло (~56 мс для полного списка). Появилась ошибка PUT. Тест не позволяет судить о стабильности, но указывает на начинающуюся деградацию.

#### gRPC

| Метод | Запросов | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки |
| --- | --- | --- | --- | --- | --- |
| GetAllTerms | 1665 | 5.6 | 8 | 23 | 0 |
| GetTermByName | 1652 | 4.8 | 7 | 8 | 56 |
| GetGraph | 1127 | 5.4 | 8 | 9 | 0 |
| AddTerm | 260 | 5.3 | 8 | 10 | 0 |
| UpdateTerm | 165 | 5.4 | 8 | 10 | 0 |
| DeleteTerm | 39 | 7.3 | 10 | 47 | 0 |
| Всего | 4908 | 5.3 | 8 | 10 | 56 |

RPS (общий): 16.4

Анализ: gRPC сохраняет высокую производительность -- среднее время ответа 5.3 мс, RPS 16.4. Ошибки GetTermByName (56) -- это `NOT_FOUND`, вызванные попыткой получить термин, который был удалён ранее. Это не ошибка сервера, а особенность сценария.

### 4.3. Стресс-тест (stress)

#### REST

| Метод | Запросов | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки |
| --- | --- | --- | --- | --- | --- |
| GET /terms (упрощ.) | 33 | 5581 | 7000 | 30000 | 1 |
| GET /terms/{term} | 1 | 4167 | 4200 | 4200 | 0 |
| POST /terms | 2 | 3690 | 5200 | 5200 | 0 |
| Всего | 36 | 5436 | 7000 | 30000 | 1 |

RPS (общий): 1.12

График динамики: Время ответа сразу выросло до секунд, один запрос занял 30 секунд (вероятно, таймаут). RPS упал ниже 3.

#### gRPC

| Метод | Запросов | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки |
| --- | --- | --- | --- | --- | --- |
| GetAllTerms | 13393 | 5.2 | 11 | 15 | 0 |
| GetTermByName | 13162 | 3.2 | 7 | 7 | 181 |
| GetGraph | 8685 | 5.2 | 11 | 13 | 0 |
| AddTerm | 2222 | 3.4 | 7 | 8 | 0 |
| UpdateTerm | 1496 | 3.4 | 7 | 8 | 0 |
| DeleteTerm | 345 | 6.8 | 13 | 19 | 0 |
| Всего | 39303 | 4.4 | 9 | 13 | 181 |

RPS (общий): 65.7

Анализ: gRPC выдерживает 200 пользователей без деградации -- среднее время 4.4 мс, RPS 65.7. Ошибки (181) -- снова `NOT_FOUND`. Пропускная способность выросла пропорционально числу пользователей.

### 4.4. Тест на стабильность (stability)

#### REST (длительность ~15 секунд)

| Метод | Запросов | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки |
| --- | --- | --- | --- | --- | --- |
| GET /terms (упрощ.) | 46 | 2841 | 5900 | 6100 | 0 |
| GET /terms (с именем) | 27 | 2373 | 5400 | 5500 | 1 |
| GET /terms/{term} | 39 | 1479 | 6100 | 6700 | 1 |
| POST /terms | 8 | 2928 | 6500 | 6500 | 0 |
| PUT /terms/{term} | 9 | 4147 | 8700 | 8700 | 2 |
| DELETE /terms/{term} | 1 | 94 | 94 | 94 | 0 |
| Всего | 130 | 2410 | 6100 | 8100 | 4 |

RPS (общий): 8.6

Анализ: Деградация наступила мгновенно -- время ответа в секундах. Одна ошибка 500 (GET /terms с именем), остальные -- 4xx? Скорее всего, таймауты или 500.

#### gRPC (длительность ~27 минут)

| Метод | Запросов | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки |
| --- | --- | --- | --- | --- | --- |
| GetAllTerms | 9898 | 11.7 | 20 | 22 | 0 |
| GetTermByName | 9987 | 4.6 | 7 | 8 | 2 |
| GetGraph | 6708 | 11.1 | 19 | 20 | 0 |
| AddTerm | 1628 | 5.0 | 8 | 8 | 0 |
| UpdateTerm | 1294 | 4.9 | 8 | 9 | 0 |
| DeleteTerm | 311 | 15.1 | 26 | 28 | 0 |
| Всего | 29826 | 8.6 | 19 | 21 | 2 |

RPS (общий): 16.6

Анализ: gRPC стабильно работает на протяжении почти получаса. Время ответа даже ниже, чем в стресс-тесте (возможно, из-за меньшего числа пользователей). Единичные ошибки -- `NOT_FOUND`.

5\. Сравнение REST и gRPC
-------------------------

### 5.1. Сводная таблица ключевых метрик

| Тест | Протокол | RPS | Среднее (мс) | p95 (мс) | p99 (мс) | Ошибки | Примечание |
| --- | --- | --- | --- | --- | --- | --- | --- |
| light | REST | 5.0 | 30.4 | 110 | 140 | 1 | Нормально |
| light | gRPC | 3.3 | 6.4 | 8 | 38 | 0 | Меньше RPS из-за wait_time |
| normal | REST | 14.9 | 41.0 | 95 | 110 | 1 | Тест короткий, начало дегр. |
| normal | gRPC | 16.4 | 5.3 | 8 | 10 | 56* | Высокая производительность |
| stress | REST | 1.1 | 5436 | 7000 | 30000 | 1 | Полная деградация |
| stress | gRPC | 65.7 | 4.4 | 9 | 13 | 181* | Отличная масштабируемость |
| stability | REST | 8.6 | 2410 | 6100 | 8100 | 4 | Быстрый провал |
| stability | gRPC | 16.6 | 8.6 | 19 | 21 | 2* | Стабильность подтверждена |

* Ошибки gRPC -- преимущественно `NOT_FOUND` (клиентские), не связаны с производительностью сервера.

### 5.2. Латентность при росте нагрузки

-   REST: латентность резко возрастает при переходе от 10 к 50 пользователям (с 30 мс до 41 мс, а при 200 -- до секунд). Причина -- блокировки SQLite и накладные расходы HTTP/1.1.

-   gRPC: латентность практически не меняется с ростом числа пользователей (остаётся в районе 4--9 мс). Это говорит об эффективной работе протокола и отсутствии конкуренции за ресурсы (вероятно, из-за быстрой обработки запросов и короткого времени удержания блокировок БД).

### 5.3. Пропускная способность

-   REST достигает пика RPS ~15 при 50 пользователях, но затем падает до 1 при 200.

-   gRPC линейно увеличивает RPS до 65 при 200 пользователях, без признаков насыщения (при текущей конфигурации).

### 5.4. Анализ overhead

-   REST использует текстовый JSON, HTTP/1.1 -- это добавляет накладные расходы на сериализацию и размер пакетов. FastAPI, хоть и асинхронный, не спасает, когда БД блокируется.

-   gRPC использует бинарный протокол (protobuf) и HTTP/2 с мультиплексированием, что минимизирует задержки и эффективно использует одно соединение.

Вывод: gRPC обеспечивает на порядок лучшую производительность и масштабируемость для данного приложения.

6\. Заключение
--------------

### Основные выводы

1.  REST API на FastAPI с SQLite приемлем только при очень низкой нагрузке (до ~10 пользователей). При 50 пользователях начинается деградация, при 200 -- сервис практически неработоспособен (время ответа в секундах, RPS падает до 1).

2.  gRPC API демонстрирует отличную масштабируемость: при 200 пользователях RPS достигает 65, среднее время ответа 4--5 мс, p99 < 15 мс. Длительный тест (27 минут) подтверждает стабильность.

3.  Основным узким местом REST является SQLite -- блокировки при конкурентной записи и даже чтении. gRPC благодаря более быстрой обработке запросов снижает время удержания блокировок, но SQLite остаётся ограничивающим фактором. Тем не менее, для gRPC он достаточен.

4.  Ошибки в gRPC-тестах (`NOT_FOUND`) связаны с логикой тестового сценария (удаление терминов) и не являются проблемой сервера.

### Рекомендации по оптимизации

-   Для REST-сервиса:

    -   Перейти на асинхронный драйвер БД (aiosqlite) и настроить пул соединений.

    -   Включить WAL-режим SQLite (`PRAGMA journal_mode=WAL`), увеличить кэш.

    -   Добавить кэширование (Redis) для часто запрашиваемых данных.

    -   Рассмотреть замену SQLite на PostgreSQL для высокой конкурентности.

-   Для gRPC-сервиса:

    -   Минимизировать ошибки `NOT_FOUND` путём синхронизации списка терминов или использования идемпотентных операций.

    -   Добавить мониторинг ресурсов (CPU, память) для раннего обнаружения проблем.

### Возможные улучшения эксперимента

-   Провести тесты с одинаковыми профилями нагрузки и длительностью для обоих протоколов.

-   Измерять потребление CPU и памяти контейнеров во время тестов.

-   Использовать распределённый режим Locust для исключения влияния одного генератора.

-   Протестировать различные соотношения чтения/записи.

### Ограничения проведённого тестирования

-   Тесты REST были слишком короткими из-за быстрой деградации, что не позволяет оценить поведение на длительных интервалах.

-   Не измерялась нагрузка на сеть и влияние сетевых задержек.

-   Генератор нагрузки и сервисы находились на одной машине -- возможна конкуренция за ресурсы CPU.

-   Версии библиотек и протоколов не фиксировались.

* * * * *

Итог: Для высоконагруженных систем или микросервисной архитектуры настоятельно рекомендуется использовать gRPC. REST может быть оставлен для совместимости или демонстрационных целей, но требует серьёзной оптимизации (замена БД, кэширование).